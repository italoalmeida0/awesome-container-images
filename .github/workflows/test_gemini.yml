name: Test Production Release with AI Notes

on:
  workflow_dispatch:
    inputs:
      service:
        description: "Service to release"
        required: true
        default: "api-gateway"
        type: choice
        options:
          - api-gateway
          - auth-service
          - payment-service
          - notification-service
      version_bump:
        description: "Version bump type"
        required: true
        default: "patch"
        type: choice
        options:
          - major
          - minor
          - patch
      dry_run:
        description: "Dry run (no actual release)"
        required: true
        default: "true"
        type: choice
        options:
          - "true"
          - "false"

env:
  REGISTRY: ghcr.io

jobs:
  prepare-release:
    runs-on: ubuntu-latest
    outputs:
      current_version: ${{ steps.version.outputs.current }}
      next_version: ${{ steps.version.outputs.next }}
      previous_tag: ${{ steps.version.outputs.previous_tag }}
      release_notes: ${{ steps.ai_notes.outputs.notes }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get version information
        id: version
        run: |
          SERVICE="${{ github.event.inputs.service }}"
          echo "üì¶ Processing release for: $SERVICE"

          LATEST_TAG=$(git tag -l "${SERVICE}-v*" --sort=-v:refname | head -1)

          if [[ -z "$LATEST_TAG" ]]; then
            echo "üéâ First release for $SERVICE"
            CURRENT_VERSION="0.0.0"
            PREVIOUS_TAG=""
          else
            CURRENT_VERSION=${LATEST_TAG#${SERVICE}-v}
            PREVIOUS_TAG=$LATEST_TAG
            echo "üìå Current version: $CURRENT_VERSION"
          fi

          IFS='.' read -r major minor patch <<< "$CURRENT_VERSION"

          case "${{ github.event.inputs.version_bump }}" in
            major)
              NEXT_VERSION="$((major + 1)).0.0"
              ;;
            minor)
              NEXT_VERSION="${major}.$((minor + 1)).0"
              ;;
            patch)
              NEXT_VERSION="${major}.${minor}.$((patch + 1))"
              ;;
          esac

          echo "current=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "next=$NEXT_VERSION" >> $GITHUB_OUTPUT
          echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT

          echo "üìà Version bump: $CURRENT_VERSION ‚Üí $NEXT_VERSION"

      - name: Collect commit information
        id: commits
        run: |
          SERVICE="${{ github.event.inputs.service }}"
          PREVIOUS_TAG="${{ steps.version.outputs.previous_tag }}"

          if [[ -z "$PREVIOUS_TAG" ]]; then
            echo "üìù Collecting all commits for first release..."
            COMPARE_FROM="$(git rev-list --max-parents=0 HEAD)"
            COMPARE_RANGE="${COMPARE_FROM}..HEAD"
          else
            echo "üìù Collecting commits since $PREVIOUS_TAG..."
            COMPARE_RANGE="${PREVIOUS_TAG}..HEAD"
          fi

          if [[ -d "$SERVICE" ]]; then
            COMMITS=$(git log $COMPARE_RANGE --pretty=format:"- %s by %an" -- ${SERVICE}/ | head -50)
            FILES_STATS=$(git diff --stat $COMPARE_RANGE -- ${SERVICE}/)
            DIFF_SUMMARY=$(git diff $COMPARE_RANGE --shortstat -- ${SERVICE}/)
          else
            echo "‚ö†Ô∏è Service directory not found, using root commits"
            COMMITS=$(git log $COMPARE_RANGE --pretty=format:"- %s by %an" | head -50)
            FILES_STATS=$(git diff --stat $COMPARE_RANGE)
            DIFF_SUMMARY=$(git diff $COMPARE_RANGE --shortstat)
          fi

          COMMIT_COUNT=$(echo "$COMMITS" | wc -l)

          if [[ -z "$COMMITS" ]]; then
            COMMITS="- Release preparation by GitHub Actions"
            DIFF_SUMMARY="Initial release"
            FILES_STATS="Initial release"
          fi

          echo "üìä Found $COMMIT_COUNT commits"
          echo "üìà Changes: $DIFF_SUMMARY"

          echo "commits<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMITS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "diff_summary=$DIFF_SUMMARY" >> $GITHUB_OUTPUT
          echo "files_stats<<EOF" >> $GITHUB_OUTPUT
          echo "$FILES_STATS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Generate AI Release Notes
        id: ai_notes
        run: |
          SERVICE="${{ github.event.inputs.service }}"
          VERSION="${{ steps.version.outputs.next }}"
          COMMITS="${{ steps.commits.outputs.commits }}"
          DIFF_SUMMARY="${{ steps.commits.outputs.diff_summary }}"

          echo "ü§ñ Generating AI-powered release notes..."

          PROMPT="Generate professional release notes for ${SERVICE} v${VERSION}.

          Changes: ${DIFF_SUMMARY}

          Recent commits:
          ${COMMITS}

          Instructions:
          1. Create an exciting 1-2 sentence summary
          2. List key highlights with emojis:
             - ‚ú® New Features
             - üêõ Bug Fixes
             - ‚ö° Performance Improvements
             - üîß Maintenance
             - üìö Documentation
             - üö® Breaking Changes (if any)
          3. Focus on user benefits, not technical details
          4. Be enthusiastic but professional
          5. Maximum 400 words
          6. Use markdown formatting

          Make developers excited about this release!"

          PROMPT_JSON=$(echo "$PROMPT" | jq -Rs .)

          RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -X POST \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${{ secrets.GEMINI_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d "{
              \"contents\": [{
                \"parts\": [{
                  \"text\": ${PROMPT_JSON}
                }]
              }],
              \"generationConfig\": {
                \"temperature\": 0.7,
                \"maxOutputTokens\": 2000,
                \"topP\": 0.95,
                \"topK\": 40
              }
            }")

          HTTP_STATUS=$(echo "$RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '/HTTP_STATUS:/d')

          if [[ "$HTTP_STATUS" != "200" ]]; then
            echo "‚ö†Ô∏è AI generation failed, using fallback"
            RELEASE_NOTES="## ${SERVICE} v${VERSION}

          This release includes various improvements and updates.

          ### Changes
          ${COMMITS}"
          else
            RELEASE_NOTES=$(echo "$RESPONSE_BODY" | jq -r '.candidates[0].content.parts[0].text // empty' 2>/dev/null)
            
            if [[ -z "$RELEASE_NOTES" ]]; then
              echo "‚ö†Ô∏è Empty response, using fallback"
              RELEASE_NOTES="## ${SERVICE} v${VERSION}

          This release includes various improvements and updates.

          ### Changes
          ${COMMITS}"
            else
              echo "‚úÖ AI release notes generated successfully!"
            fi
          fi

          echo "notes<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Release Notes File
        run: |
          SERVICE="${{ github.event.inputs.service }}"
          VERSION="${{ steps.version.outputs.next }}"
          PREVIOUS_TAG="${{ steps.version.outputs.previous_tag }}"

          if [[ -n "$PREVIOUS_TAG" ]]; then
            COMPARE_URL="[View Full Changelog](https://github.com/${{ github.repository }}/compare/${PREVIOUS_TAG}...${SERVICE}-v${VERSION})"
          else
            COMPARE_URL="**Initial Release** üéâ"
          fi

          cat << EOF > RELEASE_NOTES.md
          ${{ steps.ai_notes.outputs.notes }}

          ---

          ## üì¶ Docker Image

          Pull the latest version:
          \`\`\`bash
          docker pull ${{ env.REGISTRY }}/${{ github.repository_owner }}/${SERVICE}:v${VERSION}
          docker pull ${{ env.REGISTRY }}/${{ github.repository_owner }}/${SERVICE}:latest
          \`\`\`

          ## üìä Release Information

          - **Version:** v${VERSION}
          - **Service:** ${SERVICE}
          - **Release Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          - **Commit:** ${{ github.sha }}
          - **Build:** [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

          ## üîó Links

          - ${COMPARE_URL}
          - [Docker Registry](${{ env.REGISTRY }}/${{ github.repository_owner }}/${SERVICE})
          - [Release Assets](https://github.com/${{ github.repository }}/releases/tag/${SERVICE}-v${VERSION})
          EOF

          echo "üìÑ Release notes preview:"
          echo "================================"
          cat RELEASE_NOTES.md
          echo "================================"

      - name: Build Docker Image (Simulation)
        if: github.event.inputs.dry_run == 'true'
        run: |
          SERVICE="${{ github.event.inputs.service }}"
          VERSION="${{ steps.version.outputs.next }}"

          echo "üê≥ [DRY RUN] Would build Docker image:"
          echo "  Image: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${SERVICE}:v${VERSION}"
          echo "  Tags: v${VERSION}, latest"
          echo "  Platforms: linux/amd64, linux/arm64"

          echo "FROM alpine:latest" > Dockerfile.test
          echo "LABEL version=\"${VERSION}\"" >> Dockerfile.test
          echo "LABEL service=\"${SERVICE}\"" >> Dockerfile.test
          echo "RUN echo 'Test image for ${SERVICE} v${VERSION}'" >> Dockerfile.test

          echo "‚úÖ Docker build simulation complete"

      - name: Create GitHub Release (Simulation)
        if: github.event.inputs.dry_run == 'true'
        run: |
          SERVICE="${{ github.event.inputs.service }}"
          VERSION="${{ steps.version.outputs.next }}"
          TAG="${SERVICE}-v${VERSION}"

          echo "üì¶ [DRY RUN] Would create GitHub Release:"
          echo "  Tag: $TAG"
          echo "  Title: ${SERVICE} v${VERSION}"
          echo "  Draft: false"
          echo "  Prerelease: false"
          echo ""
          echo "Release body would be:"
          echo "--------------------------------"
          cat RELEASE_NOTES.md
          echo "--------------------------------"

      - name: Upload Release Notes Artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-notes-${{ github.event.inputs.service }}-${{ steps.version.outputs.next }}
          path: RELEASE_NOTES.md

  production-release:
    needs: prepare-release
    if: github.event.inputs.dry_run == 'false'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and Push Docker Image
        run: |
          SERVICE="${{ github.event.inputs.service }}"
          VERSION="${{ needs.prepare-release.outputs.next_version }}"

          echo "üê≥ Building real Docker image..."

          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            --tag ${{ env.REGISTRY }}/${{ github.repository_owner }}/${SERVICE}:v${VERSION} \
            --tag ${{ env.REGISTRY }}/${{ github.repository_owner }}/${SERVICE}:latest \
            --push \
            ./${SERVICE}

          echo "‚úÖ Docker image pushed successfully"

      - name: Create Git Tag
        run: |
          SERVICE="${{ github.event.inputs.service }}"
          VERSION="${{ needs.prepare-release.outputs.next_version }}"
          TAG="${SERVICE}-v${VERSION}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git tag -a "$TAG" -m "Release ${SERVICE} v${VERSION}"
          git push origin "$TAG"

          echo "üè∑Ô∏è Created tag: $TAG"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.event.inputs.service }}-v${{ needs.prepare-release.outputs.next_version }}
          name: ${{ github.event.inputs.service }} v${{ needs.prepare-release.outputs.next_version }}
          body: ${{ needs.prepare-release.outputs.release_notes }}
          draft: false
          prerelease: false
          generate_release_notes: false

      - name: Post Release Notification
        run: |
          SERVICE="${{ github.event.inputs.service }}"
          VERSION="${{ needs.prepare-release.outputs.next_version }}"

          echo "üéâ Release completed successfully!"
          echo "üì¶ Service: ${SERVICE}"
          echo "üè∑Ô∏è Version: v${VERSION}"
          echo "üê≥ Image: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${SERVICE}:v${VERSION}"
          echo "üìÑ Release: https://github.com/${{ github.repository }}/releases/tag/${SERVICE}-v${VERSION}"

  summary:
    needs: [prepare-release]
    if: always()
    runs-on: ubuntu-latest

    steps:
      - name: Release Summary
        run: |
          echo "## üìä Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Service** | ${{ github.event.inputs.service }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Version** | ${{ needs.prepare-release.outputs.current_version }} ‚Üí ${{ needs.prepare-release.outputs.next_version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Type** | ${{ github.event.inputs.version_bump }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Dry Run** | ${{ github.event.inputs.dry_run }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Workflow** | [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ github.event.inputs.dry_run }}" == "true" ]]; then
            echo "‚ÑπÔ∏è **This was a dry run.** No actual release was created." >> $GITHUB_STEP_SUMMARY
          else
            echo "‚úÖ **Release created successfully!**" >> $GITHUB_STEP_SUMMARY
          fi
