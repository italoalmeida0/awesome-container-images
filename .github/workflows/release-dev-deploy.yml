name: Build & Deploy - Service
on:
  workflow_dispatch:
    inputs:
      service:
        description: "Build & Deploy - Service"
        required: true
        default: "default"
        type: choice
        options:
          - default
          - homebrew
          - homebrew-dev
          - jupyterlab
          - jupyterlab-dev
          - vscode
          - vscode-dev

permissions:
  contents: write
  packages: write

jobs:
  prepare:
    runs-on: buildjet-2vcpu-ubuntu-2204
    outputs:
      service: ${{ steps.parse.outputs.service }}
      is_dev: ${{ steps.parse.outputs.is_dev }}
      tag_suffix: ${{ steps.parse.outputs.tag_suffix }}
      registry: ${{ steps.parse.outputs.registry }}
      build_type: ${{ steps.parse.outputs.build_type }}
      current_version: ${{ steps.version.outputs.current_version }}
      next_version: ${{ steps.version.outputs.next_version }}
      current_tag: ${{ steps.version.outputs.current_tag }}
      next_tag: ${{ steps.version.outputs.next_tag }}
      previous_tag: ${{ steps.version.outputs.previous_tag }}
      should_build: ${{ steps.parse.outputs.should_build }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Parse service and environment
        id: parse
        run: |
          INPUT="${{ github.event.inputs.service }}"

          if [[ "$INPUT" == "default" ]]; then
            echo "::warning::Default option selected - This is a safety option"
            echo "## ‚ö†Ô∏è No Build Performed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "You selected the **default** option which is a safety mechanism." >> $GITHUB_STEP_SUMMARY
            echo "Please run the workflow again and select a specific service." >> $GITHUB_STEP_SUMMARY
            echo "should_build=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "should_build=true" >> $GITHUB_OUTPUT

          if [[ "$INPUT" == *"-dev" ]]; then
            SERVICE="${INPUT%-dev}"
            IS_DEV="true"
            TAG_SUFFIX="-next-dev"
            REGISTRY="ghcr.io/italoalmeida0/aweci-dev"
            BUILD_TYPE="üîß Dev"
          else
            SERVICE="$INPUT"
            IS_DEV="false"
            TAG_SUFFIX="-next"
            REGISTRY="ghcr.io/italoalmeida0/aweci"
            BUILD_TYPE="üöÄ Release"
          fi

          if [[ ! -d "$SERVICE" ]] || [[ ! -f "$SERVICE/Dockerfile" ]]; then
            echo "‚ùå Service '$SERVICE' not found or doesn't have a Dockerfile!" >> $GITHUB_STEP_SUMMARY
            echo "should_build=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "service=${SERVICE}" >> $GITHUB_OUTPUT
          echo "is_dev=${IS_DEV}" >> $GITHUB_OUTPUT
          echo "tag_suffix=${TAG_SUFFIX}" >> $GITHUB_OUTPUT
          echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
          echo "build_type=${BUILD_TYPE}" >> $GITHUB_OUTPUT

      - name: Get current and next version
        id: version
        if: steps.parse.outputs.should_build == 'true'
        run: |
          SERVICE="${{ steps.parse.outputs.service }}"
          TAG_SUFFIX="${{ steps.parse.outputs.tag_suffix }}"

          LATEST_TAG=$(git tag -l "${SERVICE}-*${TAG_SUFFIX}" --sort=-version:refname | head -n 1)

          if [[ -z "$LATEST_TAG" ]]; then
            CURRENT_VERSION="0.0.0"
            NEXT_VERSION="0.0.1"
            PREVIOUS_TAG=""
          else
            CURRENT_VERSION=$(echo $LATEST_TAG | sed "s/${SERVICE}-//" | sed 's/-next.*//' | sed 's/-dev.*//')
            
            PREVIOUS_TAG=$(git tag -l "${SERVICE}-*${TAG_SUFFIX}" --sort=-version:refname | head -n 2 | tail -n 1)
            
            IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
            MAJOR=${VERSION_PARTS[0]:-0}
            MINOR=${VERSION_PARTS[1]:-0}
            PATCH=${VERSION_PARTS[2]:-0}
            PATCH=$((PATCH + 1))
            NEXT_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          fi

          CURRENT_TAG="${SERVICE}-${CURRENT_VERSION}${TAG_SUFFIX}"
          NEXT_TAG="${SERVICE}-${NEXT_VERSION}${TAG_SUFFIX}"

          echo "current_version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT
          echo "next_version=${NEXT_VERSION}" >> $GITHUB_OUTPUT
          echo "current_tag=${CURRENT_TAG}" >> $GITHUB_OUTPUT
          echo "next_tag=${NEXT_TAG}" >> $GITHUB_OUTPUT
          echo "previous_tag=${PREVIOUS_TAG}" >> $GITHUB_OUTPUT

          echo "üìã Building version: ${CURRENT_VERSION}"
          echo "üè∑Ô∏è Next tag will be: ${NEXT_TAG}"
          echo "üìå Previous tag was: ${PREVIOUS_TAG:-'First Release'}"

  build-arch:
    needs: prepare
    if: needs.prepare.outputs.should_build == 'true'
    strategy:
      matrix:
        include:
          - platform: linux/amd64
            runner: buildjet-4vcpu-ubuntu-2204
            arch: amd64
          - platform: linux/arm64
            runner: buildjet-4vcpu-ubuntu-2204-arm
            arch: arm64
    runs-on: ${{ matrix.runner }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push architecture-specific image
        id: build_with_cache
        continue-on-error: true
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./${{ needs.prepare.outputs.service }}/Dockerfile
          push: true
          platforms: ${{ matrix.platform }}
          cache-from: type=registry,ref=${{ needs.prepare.outputs.registry }}:${{ needs.prepare.outputs.service }}-${{ matrix.arch }}
          cache-to: type=inline
          tags: |
            ${{ needs.prepare.outputs.registry }}:${{ needs.prepare.outputs.service }}-${{ needs.prepare.outputs.current_version }}-${{ matrix.arch }}
            ${{ needs.prepare.outputs.registry }}:${{ needs.prepare.outputs.service }}-${{ matrix.arch }}
          provenance: false

      - name: Build without cache (fallback)
        if: steps.build_with_cache.outcome == 'failure'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./${{ needs.prepare.outputs.service }}/Dockerfile
          push: true
          platforms: ${{ matrix.platform }}
          no-cache: true
          tags: |
            ${{ needs.prepare.outputs.registry }}:${{ needs.prepare.outputs.service }}-${{ needs.prepare.outputs.current_version }}-${{ matrix.arch }}
            ${{ needs.prepare.outputs.registry }}:${{ needs.prepare.outputs.service }}-${{ matrix.arch }}
          provenance: false

  # ============================================
  create-manifest:
    needs: [prepare, build-arch]
    if: needs.prepare.outputs.should_build == 'true'
    runs-on: buildjet-2vcpu-ubuntu-2204
    steps:
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and push multi-arch manifest
        run: |
          REGISTRY="${{ needs.prepare.outputs.registry }}"
          SERVICE="${{ needs.prepare.outputs.service }}"
          VERSION="${{ needs.prepare.outputs.current_version }}"

          # Criar manifest para a vers√£o espec√≠fica
          docker manifest create \
            ${REGISTRY}:${SERVICE}-${VERSION} \
            ${REGISTRY}:${SERVICE}-${VERSION}-amd64 \
            ${REGISTRY}:${SERVICE}-${VERSION}-arm64

          docker manifest push ${REGISTRY}:${SERVICE}-${VERSION}

          # Criar manifest para a tag latest
          docker manifest create \
            ${REGISTRY}:${SERVICE} \
            ${REGISTRY}:${SERVICE}-${VERSION}-amd64 \
            ${REGISTRY}:${SERVICE}-${VERSION}-arm64

          docker manifest push ${REGISTRY}:${SERVICE}

          echo "‚úÖ Multi-arch manifest created and pushed"

  validate:
    needs: [prepare, create-manifest]
    if: needs.prepare.outputs.should_build == 'true'
    runs-on: buildjet-2vcpu-ubuntu-2204-arm
    steps:
      - name: Validate image healthcheck
        id: validate_health
        run: |
          echo "üè• Validating healthcheck for the built image..."
          IMAGE="${{ needs.prepare.outputs.registry }}:${{ needs.prepare.outputs.service }}-${{ needs.prepare.outputs.current_version }}"
          docker pull $IMAGE
          CONTAINER_ID=$(docker run -d \
            --name test-health-${{ github.run_id }} \
            -e PORT=8080 \
            -p 8080:8080 \
            $IMAGE)
          echo "Container started: $CONTAINER_ID"
          
          MAX_ATTEMPTS=30
          for i in $(seq 1 $MAX_ATTEMPTS); do
            sleep 10
            
            HEALTH_STATUS=$(docker inspect --format='{{.State.Health.Status}}' test-health-${{ github.run_id }} 2>/dev/null || echo "none")
            echo "Attempt $i/$MAX_ATTEMPTS: Status = $HEALTH_STATUS"
            
            case "$HEALTH_STATUS" in
              "healthy")
                echo "‚úÖ Container healthy after $((i * 10)) seconds!"
                docker rm -f test-health-${{ github.run_id }} >/dev/null 2>&1
                exit 0
                ;;
              "unhealthy")
                echo "‚ùå Container unhealthy after $((i * 10)) seconds!"
                echo "üìã Container logs:"
                docker logs --tail 50 test-health-${{ github.run_id }}
                docker rm -f test-health-${{ github.run_id }} >/dev/null 2>&1
                exit 1
                ;;
              "starting")
                echo "‚è≥ Health check still in progress..."
                ;;
              "none")
                echo "‚ö†Ô∏è No health check defined or container not running"
                if ! docker ps -q -f name=test-health-${{ github.run_id }} | grep -q .; then
                  echo "‚ùå Container stopped unexpectedly!"
                  docker logs --tail 50 test-health-${{ github.run_id }}
                  docker rm -f test-health-${{ github.run_id }} >/dev/null 2>&1
                  exit 1
                fi
                ;;
            esac
          done
          
          echo "‚è±Ô∏è Timeout after $((MAX_ATTEMPTS * 10)) seconds - Final status: $HEALTH_STATUS"
          echo "üìã Container logs:"
          docker logs --tail 50 test-health-${{ github.run_id }}
          docker rm -f test-health-${{ github.run_id }} >/dev/null 2>&1
          exit 1

  finalize:
    needs: [prepare, validate]
    if: needs.prepare.outputs.should_build == 'true' && success()
    runs-on: buildjet-2vcpu-ubuntu-2204
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Create and push next version tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "${{ needs.prepare.outputs.next_tag }}" -m "Next: ${{ needs.prepare.outputs.build_type }} ${{ needs.prepare.outputs.service }} v${{ needs.prepare.outputs.next_version }}"
          git push origin "${{ needs.prepare.outputs.next_tag }}"
          echo "‚úÖ Next version tag created: ${{ needs.prepare.outputs.next_tag }}"

      - name: Generate AI Release Notes
        if: needs.prepare.outputs.is_dev == 'false'
        id: ai_release
        run: |
          SERVICE="${{ needs.prepare.outputs.service }}"
          PREVIOUS_TAG="${{ needs.prepare.outputs.previous_tag }}"
          CURRENT_TAG="${{ needs.prepare.outputs.current_tag }}"

          if [[ -z "$PREVIOUS_TAG" ]]; then
            echo "üìù First release - using last 30 commits"
            COMPARE_FROM="HEAD~30"
            COMPARE_URL="**Initial Release** üéâ"
          else
            echo "üìù Comparing from ${PREVIOUS_TAG} to HEAD"
            COMPARE_FROM="${PREVIOUS_TAG}"
            COMPARE_URL="[View Full Changelog](https://github.com/${{ github.repository }}/compare/${PREVIOUS_TAG}...${CURRENT_TAG})"
          fi

          COMMITS=$(git log ${COMPARE_FROM}..HEAD --pretty=format:"- %s by %an" -- ${SERVICE}/ | head -30)
          FILES_CHANGED=$(git diff --stat ${COMPARE_FROM}..HEAD -- ${SERVICE}/ | tail -1)
          DIFF_SUMMARY=$(git diff ${COMPARE_FROM}..HEAD --shortstat -- ${SERVICE}/)

          read -r -d '' PROMPT << EOM || true
          You are a release notes generator for Docker container services.
          Generate professional and exciting release notes for the JUST RELEASED version: ${SERVICE} v${{ needs.prepare.outputs.current_version }}

          IMPORTANT: This version has ALREADY been built and released. Write in PAST TENSE about what WAS accomplished in this release.
          DO NOT talk about future versions or upcoming features.

          Changes summary: ${DIFF_SUMMARY}
          Files: ${FILES_CHANGED}

          Recent commits included in THIS release:
          ${COMMITS}

          Instructions:
          1. Create a catchy 1-2 sentence summary of what's NEW in this release (past tense)
          2. List key highlights that WERE delivered in this version using these emojis:
            - ‚ú® New Features
            - üêõ Bug Fixes  
            - ‚ö° Performance Improvements
            - üîß Maintenance
            - üìö Documentation
            - üö® Breaking Changes (if any)
          3. Keep it user-friendly, focus on benefits not technical details
          4. Be enthusiastic but professional
          5. Maximum 400 words
          6. Use markdown formatting
          7. Don't include installation instructions or technical details
          8. Write everything in PAST TENSE - this version is already released!

          Make developers excited to use this NEW version that's now available!
          EOM

          PROMPT_JSON=$(echo "$PROMPT" | jq -Rs .)

          echo "ü§ñ Generating release notes with Gemini..."

          RESPONSE=$(curl -s -X POST \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${{ secrets.GEMINI_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d "{
              \"contents\": [{
                \"parts\": [{
                  \"text\": ${PROMPT_JSON}
                }]
              }],
              \"generationConfig\": {
                \"temperature\": 0.7,
                \"maxOutputTokens\": 2000,
                \"topP\": 0.95,
                \"topK\": 40
              }
            }")

          ERROR=$(echo "$RESPONSE" | jq -r '.error.message // empty' 2>/dev/null)
          if [[ -n "$ERROR" ]]; then
            echo "‚ùå Gemini API Error: $ERROR"
          fi

          RELEASE_NOTES=$(echo "$RESPONSE" | jq -r '.candidates[0].content.parts[0].text // "Error generating release notes"')

          if [[ "$RELEASE_NOTES" == "Error generating release notes" ]]; then
            echo "‚ö†Ô∏è Failed to generate AI release notes, using fallback"
            RELEASE_NOTES="## ${SERVICE} v${{ needs.prepare.outputs.next_version }}

            This release includes various improvements and updates to the ${SERVICE} service.

            ### üìã Changes
            ${COMMITS}

            For detailed changes, please check the changelog link below."
          fi

          cat << EOF > release_notes.md
          ${RELEASE_NOTES}

          ---

          ## üì¶ Docker Image

          Pull the latest version:
          \`\`\`bash
          docker pull ${{ needs.prepare.outputs.registry }}:${{ needs.prepare.outputs.service }}-${{ needs.prepare.outputs.current_version }}
          \`\`\`

          Or use the latest tag:
          \`\`\`bash
          docker pull ${{ needs.prepare.outputs.registry }}:${{ needs.prepare.outputs.service }}
          \`\`\`

          ## ‚úÖ Quality Assurance
          - Container health validated before release
          - Multi-platform support: \`linux/amd64\`, \`linux/arm64\`
          - Build cache optimized for faster deployments
          - Parallel architecture builds for faster CI/CD

          ## üìä Changelog
          ${COMPARE_URL}

          ## üè∑Ô∏è Version Info
          - **Current Release:** v${{ needs.prepare.outputs.current_version }}
          - **Previous Version:** ${PREVIOUS_TAG:-'Initial Release'}
          - **Registry:** ${{ needs.prepare.outputs.registry }}
          EOF

          echo "‚ú® Release notes generated successfully!"

      - name: Create GitHub Release
        if: needs.prepare.outputs.is_dev == 'false' && steps.ai_release.outcome == 'success'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.prepare.outputs.current_tag }}
          name: "${{ needs.prepare.outputs.service }} v${{ needs.prepare.outputs.current_version }}"
          body_path: release_notes.md
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update Registry Info
        run: |
          echo "üîç Discovering all services dynamically..."
          IS_DEV="${{ needs.prepare.outputs.is_dev }}"
          python3 << 'EOF'
          import os
          import subprocess
          from datetime import datetime

          is_dev = os.environ.get('IS_DEV', 'false') == 'true'

          services = []
          for item in os.listdir('.'):
              if os.path.isdir(item) and not item.startswith('.') and not item.startswith('_'):
                  if os.path.exists(f'{item}/Dockerfile'):
                      services.append(item)

          versions = {}

          for service in services:
            if is_dev:
              tag = subprocess.run(f'git tag -l "{service}-*-next-dev" | sort -V | tail -n 1', 
                                  shell=True, capture_output=True, text=True).stdout.strip()
              registry_suffix = "-dev"
            else:
              tag = subprocess.run(f'git tag -l "{service}-*-next" | grep -v "\-dev" | sort -V | tail -n 1', 
                                  shell=True, capture_output=True, text=True).stdout.strip()
              registry_suffix = ""
            
            def find_docker_version(service, tag, registry_suffix=""):
              if not tag:
                return "none"
              
              suffixes_to_remove = ["-next-dev", "-next"]
              tag_version = tag.replace(f"{service}-", "")
              
              for suffix in suffixes_to_remove:
                if suffix in tag_version:
                  tag_version = tag_version.replace(suffix, "")
                  break
              
              try:
                parts = tag_version.split('.')
                major, minor, patch = parts[0], parts[1], int(parts[2])
              except (IndexError, ValueError):
                return "none"
              
              for i in range(patch, -1, -1):
                check_version = f"{major}.{minor}.{i}"
                registry = f"ghcr.io/italoalmeida0/aweci{registry_suffix}"
                  
                result = subprocess.run(
                  f'docker manifest inspect {registry}:{service}-{check_version} 2>/dev/null',
                  shell=True, 
                  capture_output=True
                )
                
                if result.returncode == 0:
                  return check_version
              
              return "none"
            
            version = find_docker_version(service, tag, registry_suffix=registry_suffix)
            versions[service] = version

          build_type = "development" if is_dev else "production"

          toml_content = f"""# Latest Versions | ü™∏ AWECI - Awesome Container Images üêã
          # Generated at {datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")}
          # Build Type: {build_type.upper()}

          [metadata]
          timestamp = "{datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")}"
          total_services = {len(services)}
          build_type = "{build_type}"

          [services]
          available = {services}

          [versions.{build_type}]"""

          for service in sorted(services):
            toml_content += f'\n{service} = "{versions[service]}"'

          toml_content += "\n"

          print("Generated TOML:")
          print(toml_content)

          with open('registry-info.toml', 'w') as f:
            f.write(toml_content)

          print("\nTOML saved to registry-info.toml")
          EOF
        env:
          IS_DEV: ${{ needs.prepare.outputs.is_dev }}

      - name: Create default Dockerfile
        run: |
          cat << 'EOF' > Dockerfile.default
          FROM busybox:latest
          COPY registry-info.toml /info.toml
          CMD cat /info.toml
          EOF

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Update Registry Latest Tags
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.default
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ needs.prepare.outputs.registry }}:latest
            ${{ needs.prepare.outputs.registry }}:default

      - name: Final Summary
        run: |
          docker pull ${{ needs.prepare.outputs.registry }}:default

          echo "## ‚úÖ Build Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Built:** ${{ needs.prepare.outputs.service }} v${{ needs.prepare.outputs.current_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Next Version:** v${{ needs.prepare.outputs.next_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Type:** ${{ needs.prepare.outputs.build_type }}" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** ${{ needs.prepare.outputs.next_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**Health:** ‚úÖ Validated" >> $GITHUB_STEP_SUMMARY
          echo "**Build Method:** üöÄ Parallel Architecture Builds" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üì¶ Registry Status:" >> $GITHUB_STEP_SUMMARY
          echo '```toml' >> $GITHUB_STEP_SUMMARY
          docker run --rm ${{ needs.prepare.outputs.registry }}:default >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
