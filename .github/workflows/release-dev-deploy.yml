name: Build & Deploy - Auto Versioning
on:
  workflow_dispatch:
    inputs:
      service:
        description: "Service to Build & Deploy"
        required: true
        default: "default"
        type: choice
        options:
          - default
          - jupyterlab
          - jupyterlab-dev
          - vscode
          - vscode-dev

permissions:
  contents: write
  packages: write

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Parse service and environment
        id: parse
        run: |
          INPUT="${{ github.event.inputs.service }}"

          if [[ "$INPUT" == "default" ]]; then
            echo "::warning::Default option selected - This is a safety option"
            echo "## ‚ö†Ô∏è No Build Performed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "You selected the **default** option which is a safety mechanism." >> $GITHUB_STEP_SUMMARY
            echo "Please run the workflow again and select a specific service." >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

          echo "skip_all=false" >> $GITHUB_OUTPUT

          if [[ "$INPUT" == *"-dev" ]]; then
            SERVICE="${INPUT%-dev}"
            IS_DEV="true"
            TAG_SUFFIX="-next-dev"
            REGISTRY="ghcr.io/italoalmeida0/aweci-dev"
            BUILD_TYPE="üîß Dev"
          else
            SERVICE="$INPUT"
            IS_DEV="false"
            TAG_SUFFIX="-next"
            REGISTRY="ghcr.io/italoalmeida0/aweci"
            BUILD_TYPE="üöÄ Release"
          fi

          if [[ ! -d "$SERVICE" ]] || [[ ! -f "$SERVICE/Dockerfile" ]]; then
            echo "‚ùå Service '$SERVICE' not found or doesn't have a Dockerfile!" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

          echo "service=${SERVICE}" >> $GITHUB_OUTPUT
          echo "is_dev=${IS_DEV}" >> $GITHUB_OUTPUT
          echo "tag_suffix=${TAG_SUFFIX}" >> $GITHUB_OUTPUT
          echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
          echo "build_type=${BUILD_TYPE}" >> $GITHUB_OUTPUT

      - name: Get current and next version
        id: version
        run: |
          SERVICE="${{ steps.parse.outputs.service }}"
          TAG_SUFFIX="${{ steps.parse.outputs.tag_suffix }}"

          LATEST_TAG=$(git tag -l "${SERVICE}-*${TAG_SUFFIX}" --sort=-version:refname | head -n 1)

          if [[ -z "$LATEST_TAG" ]]; then
            CURRENT_VERSION="0.0.0"
            NEXT_VERSION="0.0.1"
            PREVIOUS_TAG=""
          else
            CURRENT_VERSION=$(echo $LATEST_TAG | sed "s/${SERVICE}-//" | sed 's/-next.*//' | sed 's/-dev.*//')
            
            PREVIOUS_TAG=$(git tag -l "${SERVICE}-*${TAG_SUFFIX}" --sort=-version:refname | head -n 2 | tail -n 1)
            
            IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
            MAJOR=${VERSION_PARTS[0]:-0}
            MINOR=${VERSION_PARTS[1]:-0}
            PATCH=${VERSION_PARTS[2]:-0}
            PATCH=$((PATCH + 1))
            NEXT_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          fi

          CURRENT_TAG="${SERVICE}-${CURRENT_VERSION}${TAG_SUFFIX}"
          NEXT_TAG="${SERVICE}-${NEXT_VERSION}${TAG_SUFFIX}"

          echo "current_version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT
          echo "next_version=${NEXT_VERSION}" >> $GITHUB_OUTPUT
          echo "current_tag=${CURRENT_TAG}" >> $GITHUB_OUTPUT
          echo "next_tag=${NEXT_TAG}" >> $GITHUB_OUTPUT
          echo "previous_tag=${PREVIOUS_TAG}" >> $GITHUB_OUTPUT

          echo "üìã Building version: ${CURRENT_VERSION}"
          echo "üè∑Ô∏è Next tag will be: ${NEXT_TAG}"
          echo "üìå Previous tag was: ${PREVIOUS_TAG:-'First Release'}"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push service image
        id: docker_build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./${{ steps.parse.outputs.service }}/Dockerfile
          push: true
          platforms: ${{ steps.parse.outputs.is_dev == 'true' && 'linux/amd64' || 'linux/amd64,linux/arm64' }}
          cache-from: type=registry,ref=${{ steps.parse.outputs.registry }}:${{ steps.parse.outputs.service }}-buildcache
          cache-to: type=registry,ref=${{ steps.parse.outputs.registry }}:${{ steps.parse.outputs.service }}-buildcache,mode=max
          tags: |
            ${{ steps.parse.outputs.registry }}:${{ steps.parse.outputs.service }}-${{ steps.version.outputs.current_version }}
            ${{ steps.parse.outputs.registry }}:${{ steps.parse.outputs.service }}

      - name: Validate image healthcheck
        id: validate_health
        run: |
          echo "üè• Validating healthcheck for the built image..."

          IMAGE="${{ steps.parse.outputs.registry }}:${{ steps.parse.outputs.service }}-${{ steps.version.outputs.current_version }}"

          docker pull $IMAGE

          CONTAINER_ID=$(docker run -d \
            --name test-health-${{ github.run_id }} \
            -e PORT=8080 \
            -p 8080:8080 \
            $IMAGE)

          echo "Container started: $CONTAINER_ID"

          for i in 1 2 3 4 5; do
            sleep 10
            
            HEALTH_STATUS=$(docker inspect --format='{{.State.Health.Status}}' test-health-${{ github.run_id }} 2>/dev/null || echo "none")
            echo "Attempt $i/5: Status = $HEALTH_STATUS"
            
            if [ "$HEALTH_STATUS" = "healthy" ]; then
              echo "‚úÖ Container healthy!"
              docker rm -f test-health-${{ github.run_id }} >/dev/null 2>&1
              exit 0
            elif [ "$HEALTH_STATUS" = "unhealthy" ]; then
              echo "‚ùå Container unhealthy!"
              docker rm -f test-health-${{ github.run_id }} >/dev/null 2>&1
              exit 1
            fi
          done
              
          echo "‚è±Ô∏è Timeout after 50 seconds - Status: $HEALTH_STATUS"
          docker logs --tail 20 test-health-${{ github.run_id }}
          docker rm -f test-health-${{ github.run_id }} >/dev/null 2>&1
          exit 1

      - name: Create and push next version tag
        if: success() && steps.docker_build.outcome == 'success' && steps.validate_health.outcome == 'success'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "${{ steps.version.outputs.next_tag }}" -m "Next: ${{ steps.parse.outputs.build_type }} ${{ steps.parse.outputs.service }} v${{ steps.version.outputs.next_version }}"
          git push origin "${{ steps.version.outputs.next_tag }}"
          echo "‚úÖ Next version tag created: ${{ steps.version.outputs.next_tag }}"

      - name: Generate AI Release Notes
        if: success() && steps.parse.outputs.is_dev == 'false' && steps.docker_build.outcome == 'success' && steps.validate_health.outcome == 'success'
        id: ai_release
        run: |
          SERVICE="${{ steps.parse.outputs.service }}"
          PREVIOUS_TAG="${{ steps.version.outputs.previous_tag }}"
          CURRENT_TAG="${{ steps.version.outputs.current_tag }}"

          if [[ -z "$PREVIOUS_TAG" ]]; then
            echo "üìù First release - using last 30 commits"
            COMPARE_FROM="HEAD~30"
            COMPARE_URL="**Initial Release** üéâ"
          else
            echo "üìù Comparing from ${PREVIOUS_TAG} to HEAD"
            COMPARE_FROM="${PREVIOUS_TAG}"
            COMPARE_URL="[View Full Changelog](https://github.com/${{ github.repository }}/compare/${PREVIOUS_TAG}...${CURRENT_TAG})"
          fi

          COMMITS=$(git log ${COMPARE_FROM}..HEAD --pretty=format:"- %s by %an" -- ${SERVICE}/ | head -30)
          FILES_CHANGED=$(git diff --stat ${COMPARE_FROM}..HEAD -- ${SERVICE}/ | tail -1)
          DIFF_SUMMARY=$(git diff ${COMPARE_FROM}..HEAD --shortstat -- ${SERVICE}/)

          read -r -d '' PROMPT << EOM || true
          You are a release notes generator for Docker container services.
          Generate professional and exciting release notes for: ${SERVICE} v${{ steps.version.outputs.next_version }}

          Changes summary: ${DIFF_SUMMARY}
          Files: ${FILES_CHANGED}

          Recent commits:
          ${COMMITS}

          Instructions:
          1. Create a catchy 1-2 sentence summary of what's new
          2. List key highlights organized by category using these emojis:
             - ‚ú® New Features
             - üêõ Bug Fixes  
             - ‚ö° Performance Improvements
             - üîß Maintenance
             - üìö Documentation
             - üö® Breaking Changes (if any)
          3. Keep it user-friendly, focus on benefits not technical details
          4. Be enthusiastic but professional
          5. Maximum 400 words
          6. Use markdown formatting
          7. Don't include installation instructions or technical details

          Make developers excited to use this new version!
          EOM

          PROMPT_JSON=$(echo "$PROMPT" | jq -Rs .)

          echo "ü§ñ Generating release notes with Gemini 2.5 Flash..."

          RESPONSE=$(curl -s -X POST \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${{ secrets.GEMINI_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d "{
              \"contents\": [{
                \"parts\": [{
                  \"text\": ${PROMPT_JSON}
                }]
              }],
              \"generationConfig\": {
                \"temperature\": 0.8,
                \"maxOutputTokens\": 800,
                \"topP\": 0.95
              }
            }")

          RELEASE_NOTES=$(echo "$RESPONSE" | jq -r '.candidates[0].content.parts[0].text // "Error generating release notes"')

          if [[ "$RELEASE_NOTES" == "Error generating release notes" ]]; then
            echo "‚ö†Ô∏è Failed to generate AI release notes, using fallback"
            RELEASE_NOTES="## ${SERVICE} v${{ steps.version.outputs.next_version }}

            This release includes various improvements and updates to the ${SERVICE} service.

            ### üìã Changes
            ${COMMITS}

            For detailed changes, please check the changelog link below."
          fi

          cat << EOF > release_notes.md
          ${RELEASE_NOTES}

          ---

          ## üì¶ Docker Image

          Pull the latest version:
          \`\`\`bash
          docker pull ${{ steps.parse.outputs.registry }}:${{ steps.parse.outputs.service }}-${{ steps.version.outputs.current_version }}
          \`\`\`

          Or use the latest tag:
          \`\`\`bash
          docker pull ${{ steps.parse.outputs.registry }}:${{ steps.parse.outputs.service }}
          \`\`\`

          ## ‚úÖ Quality Assurance
          - Container health validated before release
          - Multi-platform support: \`linux/amd64\`, \`linux/arm64\`
          - Build cache optimized for faster deployments

          ## üìä Changelog
          ${COMPARE_URL}

          ## üè∑Ô∏è Version Info
          - **Released:** v${{ steps.version.outputs.current_version }}
          - **Next:** v${{ steps.version.outputs.next_version }}
          - **Registry:** ${{ steps.parse.outputs.registry }}
          EOF

          echo "‚ú® Release notes generated successfully!"

      - name: Create GitHub Release
        if: success() && steps.parse.outputs.is_dev == 'false' && steps.docker_build.outcome == 'success' && steps.validate_health.outcome == 'success' && steps.ai_release.outcome == 'success'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.current_tag }}
          name: "${{ steps.parse.outputs.service }} v${{ steps.version.outputs.current_version }}"
          body_path: release_notes.md
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Discover and collect all services
        id: discover
        run: |
          echo "üîç Discovering all services dynamically..."
          python3 << 'EOF'
          import os
          import subprocess
          from datetime import datetime

          services = []
          for item in os.listdir('.'):
              if os.path.isdir(item) and not item.startswith('.') and not item.startswith('_'):
                  if os.path.exists(f'{item}/Dockerfile'):
                      services.append(item)

          production_versions = {}
          development_versions = {}

          for service in services:
            prod_tag = subprocess.run(f'git tag -l "{service}-*-next" | grep -v "\-dev" | sort -V | tail -n 1', 
                                    shell=True, capture_output=True, text=True).stdout.strip()
            dev_tag = subprocess.run(f'git tag -l "{service}-*-next-dev" | sort -V | tail -n 1', 
                                    shell=True, capture_output=True, text=True).stdout.strip()
            
            def find_docker_version(service, tag, registry_suffix=""):
              if not tag:
                return "none"
              
              suffixes_to_remove = ["-next-dev", "-next"]
              tag_version = tag.replace(f"{service}-", "")
              
              for suffix in suffixes_to_remove:
                if suffix in tag_version:
                  tag_version = tag_version.replace(suffix, "")
                  break
            
              try:
                parts = tag_version.split('.')
                major, minor, patch = parts[0], parts[1], int(parts[2])
              except (IndexError, ValueError):
                return "none"
              
              for i in range(patch, -1, -1):
                check_version = f"{major}.{minor}.{i}"
                registry = f"ghcr.io/italoalmeida0/aweci{registry_suffix}"
                  
                result = subprocess.run(
                  f'docker manifest inspect {registry}:{service}-{check_version} 2>/dev/null',
                  shell=True, 
                  capture_output=True
                )
                
                if result.returncode == 0:
                  return check_version
              
              return "none"

            prod_version = find_docker_version(service, prod_tag, registry_suffix="")
            dev_version = find_docker_version(service, dev_tag, registry_suffix="-dev")
            
            production_versions[service] = prod_version
            development_versions[service] = dev_version

          toml_content = f"""# Latest Versions | ü™∏ AWECI - Awesome Container Images üêã
          # Generated at {datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")}

          [metadata]
          timestamp = "{datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")}"
          total_services = {len(services)}

          [services]
          available = {services}

          [versions.production]"""

          for service in sorted(services):
            toml_content += f'\n{service} = "{production_versions[service]}"'

          toml_content += "\n\n[versions.development]"

          for service in sorted(services):
            toml_content += f'\n{service} = "{development_versions[service]}"'

          toml_content += "\n"

          print("Generated TOML:")
          print(toml_content)

          with open('registry-info.toml', 'w') as f:
            f.write(toml_content)

          print("\nTOML saved to registry-info.toml")
          EOF

      - name: Create default Dockerfile
        run: |
          cat << 'EOF' > Dockerfile.default
          FROM busybox:latest
          COPY registry-info.toml /info.toml
          CMD cat /info.toml
          EOF

      - name: Update PROD latest
        if: steps.parse.outputs.is_dev == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.default
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ghcr.io/italoalmeida0/aweci:latest
            ghcr.io/italoalmeida0/aweci:default

      - name: Update DEV latest
        if: steps.parse.outputs.is_dev == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.default
          push: true
          platforms: linux/amd64
          tags: |
            ghcr.io/italoalmeida0/aweci-dev:latest
            ghcr.io/italoalmeida0/aweci-dev:default

      - name: Final Summary
        run: |
          if [[ "${{ steps.parse.outputs.is_dev }}" == "true" ]]; then
            docker pull ghcr.io/italoalmeida0/aweci-dev:default
          else
            docker pull ghcr.io/italoalmeida0/aweci:default
          fi

          echo "## ‚úÖ Build Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Built:** ${{ steps.parse.outputs.service }} v${{ steps.version.outputs.current_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Next Version:** v${{ steps.version.outputs.next_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Type:** ${{ steps.parse.outputs.build_type }}" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** ${{ steps.version.outputs.next_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**Health:** ‚úÖ Validated" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üì¶ Registry Status:" >> $GITHUB_STEP_SUMMARY
          echo '```toml' >> $GITHUB_STEP_SUMMARY

          if [[ "${{ steps.parse.outputs.is_dev }}" == "true" ]]; then
            docker run --rm ghcr.io/italoalmeida0/aweci-dev:default >> $GITHUB_STEP_SUMMARY
          else
            docker run --rm ghcr.io/italoalmeida0/aweci:default >> $GITHUB_STEP_SUMMARY
          fi

          echo '```' >> $GITHUB_STEP_SUMMARY
